<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDF Triple Hashing Algorithm Tutorial</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .tutorial-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .tutorial-section:hover {
            transform: translateY(-5px);
        }

        .section-title {
            font-size: 1.8rem;
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .algorithm-box {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .line-number {
            color: #6c757d;
            margin-right: 10px;
            user-select: none;
        }

        .demo-container {
            background: #f7fafc;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Courier New', monospace;
            transition: border-color 0.3s ease;
            resize: vertical;
        }

        .input-group textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2c3e50 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .execution-step {
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s ease;
        }

        .execution-step.active {
            border-color: #3498db;
            background: #f8f9ff;
            transform: scale(1.02);
        }

        .step-header {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .step-number {
            background: #3498db;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            margin-right: 10px;
        }

        .triple-display {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            margin: 5px 0;
            border-left: 4px solid #3498db;
        }

        .hash-result {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            word-break: break-all;
            margin: 5px 0;
        }

        .bnode-highlight {
            background: #ffe6e6;
            padding: 2px 4px;
            border-radius: 3px;
            color: #c0392b;
            font-weight: bold;
        }

        .magic-value {
            background: #e6f3ff;
            padding: 2px 4px;
            border-radius: 3px;
            color: #2980b9;
            font-weight: bold;
        }

        .grid-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .result-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .graph-visualization {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .node {
            display: inline-block;
            padding: 8px 12px;
            margin: 5px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .uri-node {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .bnode-node {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .literal-node {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeaa7;
        }

        .edge {
            margin: 0 10px;
            color: #6c757d;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .grid-layout {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔗 RDF Triple Hashing Algorithm</h1>
            <p>Interactive Tutorial for Blank Node Handling in RDF Graph Hashing</p>
        </div>

        <!-- Algorithm Overview -->
        <div class="tutorial-section">
            <h2 class="section-title">Algorithm Overview</h2>
            <p>This algorithm computes hashes for RDF triples while handling blank nodes (BNodes) specially to ensure consistent hashing across different graph representations.</p>
            
            <div class="algorithm-box">
<span class="line-number">1</span> function Hash(triple)<br>
<span class="line-number">2</span> subject = subject of triple<br>
<span class="line-number">3</span> predicate = predicate of triple<br>
<span class="line-number">4</span> object = object of triple<br>
<span class="line-number">5</span><br>
<span class="line-number">6</span> if subject is BNode then<br>
<span class="line-number">7</span>     serialisation(subject) = "Magic_S"<br>
<span class="line-number">8</span> else<br>
<span class="line-number">9</span>     serialisation(subject) = NTriples(subject)<br>
<span class="line-number">10</span><br>
<span class="line-number">11</span> if object is BNode then<br>
<span class="line-number">12</span>     serialisation(object) = "Magic_O"<br>
<span class="line-number">13</span> else<br>
<span class="line-number">14</span>     serialisation(object) = NTriples(object)<br>
<span class="line-number">15</span><br>
<span class="line-number">16</span> serialisation(predicate) = NTriples(predicate)<br>
<span class="line-number">17</span> concatenation = Concatenate(serialisation(subject), serialisation(predicate), serialisation(object))<br>
<span class="line-number">18</span> return SHA-256(concatenation)<br>
<span class="line-number">19</span><br>
<span class="line-number">20</span> for triple in graph do<br>
<span class="line-number">21</span>     basic_triple_hash = Hash(triple)<br>
<span class="line-number">22</span>     subject1 = subject of triple<br>
<span class="line-number">23</span>     predicate1 = predicate of triple<br>
<span class="line-number">24</span>     object1 = object of triple<br>
<span class="line-number">25</span><br>
<span class="line-number">26</span>     if subject1 is BNode then<br>
<span class="line-number">27</span>         for all triples with subject1 in object position<br>
<span class="line-number">28</span>             compute Hash(triple)<br>
<span class="line-number">29</span>             add to total_hash<br>
<span class="line-number">30</span><br>
<span class="line-number">31</span>     if object1 is BNode then<br>
<span class="line-number">32</span>         for all triples with object1 in subject position<br>
<span class="line-number">33</span>             compute Hash(triple)<br>
<span class="line-number">34</span>             add to total_hash
            </div>
        </div>

        <!-- Interactive Demo -->
        <div class="tutorial-section">
            <h2 class="section-title">Interactive Demo</h2>
            <div class="demo-container">
                <h3>🎯 Test the Algorithm</h3>
                <div class="input-group">
                    <label for="rdf-input">Enter RDF triples (N-Triples format):</label>
                    <textarea id="rdf-input" rows="8" placeholder="Enter RDF triples, one per line">_:b1 <http://example.org/name> "Alice" .
_:b1 <http://example.org/age> "30" .
<http://example.org/person1> <http://example.org/knows> _:b1 .
_:b2 <http://example.org/name> "Bob" .
_:b1 <http://example.org/friend> _:b2 .</textarea>
                </div>
                <button class="btn" onclick="executeAlgorithm()">Execute Algorithm</button>
                <button class="btn" onclick="loadExample('simple')">Load Simple Example</button>
                <button class="btn" onclick="loadExample('complex')">Load Complex Example</button>
            </div>

            <div class="grid-layout">
                <div class="result-panel">
                    <h4>📊 Execution Steps</h4>
                    <div id="execution-steps"></div>
                </div>
                <div class="result-panel">
                    <h4>🔍 Graph Visualization</h4>
                    <div id="graph-viz"></div>
                </div>
            </div>
        </div>

        <!-- Key Concepts -->
        <div class="tutorial-section">
            <h2 class="section-title">Key Concepts</h2>
            <div class="grid-layout">
                <div>
                    <h3>🔤 Magic Values</h3>
                    <p><strong>Magic_S</strong> and <strong>Magic_O</strong> are special placeholder values used instead of actual blank node identifiers. This ensures:</p>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li>Consistent hashing across different BNode labelings</li>
                        <li>Position-aware blank node handling</li>
                        <li>Deterministic hash computation</li>
                    </ul>
                </div>
                <div>
                    <h3>🔗 Blank Node Dependencies</h3>
                    <p>The algorithm tracks relationships where blank nodes appear in different positions:</p>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li>When a BNode is a subject, find triples where it's an object</li>
                        <li>When a BNode is an object, find triples where it's a subject</li>
                        <li>This creates a dependency graph for comprehensive hashing</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple SHA-256 implementation for demo purposes
        async function sha256(message) {
            const msgBuffer = new TextEncoder().encode(message);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Parse N-Triples format
        function parseNTriples(input) {
            const triples = [];
            const lines = input.trim().split('\n');
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) continue;
                
                // Simple N-Triples parser
                const match = trimmed.match(/^(\S+)\s+(\S+)\s+(.+?)\s*\.$/);
                if (match) {
                    triples.push({
                        subject: match[1],
                        predicate: match[2],
                        object: match[3]
                    });
                }
            }
            return triples;
        }

        // Check if a term is a blank node
        function isBNode(term) {
            return term.startsWith('_:');
        }

        // Convert to N-Triples serialization
        function toNTriples(term) {
            if (term.startsWith('<') && term.endsWith('>')) {
                return term; // URI
            } else if (term.startsWith('"')) {
                return term; // Literal
            } else if (term.startsWith('_:')) {
                return term; // BNode (though we'll replace with magic values)
            }
            return `<${term}>`;
        }

        // Hash a single triple
        async function hashTriple(triple) {
            let subjectSer, objectSer, predicateSer;
            
            // Handle subject
            if (isBNode(triple.subject)) {
                subjectSer = "Magic_S";
            } else {
                subjectSer = toNTriples(triple.subject);
            }
            
            // Handle object
            if (isBNode(triple.object)) {
                objectSer = "Magic_O";
            } else {
                objectSer = toNTriples(triple.object);
            }
            
            // Handle predicate (always URI)
            predicateSer = toNTriples(triple.predicate);
            
            const concatenation = subjectSer + predicateSer + objectSer;
            const hash = await sha256(concatenation);
            
            return {
                hash,
                serialization: {
                    subject: subjectSer,
                    predicate: predicateSer,
                    object: objectSer
                },
                concatenation
            };
        }

        // Find related triples for blank nodes
        function findRelatedTriples(triples, bnode, position) {
            const related = [];
            for (const triple of triples) {
                if (position === 'subject' && triple.object === bnode) {
                    related.push(triple);
                } else if (position === 'object' && triple.subject === bnode) {
                    related.push(triple);
                }
            }
            return related;
        }

        // Execute the full algorithm
        async function executeAlgorithm() {
            const input = document.getElementById('rdf-input').value;
            const triples = parseNTriples(input);
            
            if (triples.length === 0) {
                document.getElementById('execution-steps').innerHTML = '<p>No valid triples found. Please check your input format.</p>';
                return;
            }
            
            const steps = [];
            const allHashes = [];
            
            // Visualize the graph
            visualizeGraph(triples);
            
            for (let i = 0; i < triples.length; i++) {
                const triple = triples[i];
                
                // Step 1: Hash the basic triple
                const basicHash = await hashTriple(triple);
                steps.push({
                    type: 'basic',
                    tripleIndex: i,
                    triple,
                    hash: basicHash,
                    step: `Hash triple ${i + 1}`
                });
                allHashes.push(basicHash.hash);
                
                // Step 2: Handle blank node dependencies
                if (isBNode(triple.subject)) {
                    const relatedTriples = findRelatedTriples(triples, triple.subject, 'subject');
                    for (const relatedTriple of relatedTriples) {
                        const relatedHash = await hashTriple(relatedTriple);
                        steps.push({
                            type: 'dependency',
                            triple: relatedTriple,
                            hash: relatedHash,
                            reason: `BNode ${triple.subject} appears as object in related triple`,
                            step: `Dependency hash for ${triple.subject}`
                        });
                        allHashes.push(relatedHash.hash);
                    }
                }
                
                if (isBNode(triple.object)) {
                    const relatedTriples = findRelatedTriples(triples, triple.object, 'object');
                    for (const relatedTriple of relatedTriples) {
                        const relatedHash = await hashTriple(relatedTriple);
                        steps.push({
                            type: 'dependency',
                            triple: relatedTriple,
                            hash: relatedHash,
                            reason: `BNode ${triple.object} appears as subject in related triple`,
                            step: `Dependency hash for ${triple.object}`
                        });
                        allHashes.push(relatedHash.hash);
                    }
                }
            }
            
            // Calculate total hash
            const totalHash = await sha256(allHashes.join(''));
            steps.push({
                type: 'total',
                hash: { hash: totalHash },
                step: 'Final combined hash',
                allHashes
            });
            
            displayExecutionSteps(steps);
        }

        // Display execution steps
        function displayExecutionSteps(steps) {
            const container = document.getElementById('execution-steps');
            let html = '';
            
            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];
                html += `<div class="execution-step" id="step-${i}">`;
                html += `<div class="step-header">`;
                html += `<div class="step-number">${i + 1}</div>`;
                html += `<span>${step.step}</span>`;
                html += `</div>`;
                
                if (step.type === 'basic' || step.type === 'dependency') {
                    html += `<div class="triple-display">`;
                    html += formatTriple(step.triple);
                    html += `</div>`;
                    
                    if (step.reason) {
                        html += `<div style="font-style: italic; color: #666; margin: 5px 0;">${step.reason}</div>`;
                    }
                    
                    html += `<div style="margin: 10px 0;">`;
                    html += `<strong>Serialization:</strong><br>`;
                    html += `Subject: <span class="${isBNode(step.triple.subject) ? 'magic-value' : ''}">${step.hash.serialization.subject}</span><br>`;
                    html += `Predicate: ${step.hash.serialization.predicate}<br>`;
                    html += `Object: <span class="${isBNode(step.triple.object) ? 'magic-value' : ''}">${step.hash.serialization.object}</span><br>`;
                    html += `</div>`;
                    
                    html += `<div style="margin: 10px 0;">`;
                    html += `<strong>Concatenation:</strong> <code>${step.hash.concatenation}</code>`;
                    html += `</div>`;
                    
                    html += `<div class="hash-result">`;
                    html += `SHA-256: ${step.hash.hash}`;
                    html += `</div>`;
                } else if (step.type === 'total') {
                    html += `<div style="margin: 10px 0;">`;
                    html += `<strong>All computed hashes:</strong><br>`;
                    for (const hash of step.allHashes) {
                        html += `<code style="display: block; margin: 2px 0;">${hash}</code>`;
                    }
                    html += `</div>`;
                    
                    html += `<div class="hash-result" style="background: #27ae60; font-size: 1.1rem;">`;
                    html += `<strong>FINAL GRAPH HASH: ${step.hash.hash}</strong>`;
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            container.innerHTML = html;
        }

        // Format triple for display
        function formatTriple(triple) {
            let html = '';
            
            // Subject
            if (isBNode(triple.subject)) {
                html += `<span class="bnode-highlight">${triple.subject}</span>`;
            } else {
                html += `<span>${triple.subject}</span>`;
            }
            
            html += ` `;
            
            // Predicate
            html += `<span>${triple.predicate}</span>`;
            
            html += ` `;
            
            // Object
            if (isBNode(triple.object)) {
                html += `<span class="bnode-highlight">${triple.object}</span>`;
            } else {
                html += `<span>${triple.object}</span>`;
            }
            
            html += ` .`;
            
            return html;
        }

        // Visualize the graph
        function visualizeGraph(triples) {
            const container = document.getElementById('graph-viz');
            let html = '<h5>Graph Structure:</h5>';
            
            const nodes = new Set();
            const edges = [];
            
            for (const triple of triples) {
                nodes.add(triple.subject);
                nodes.add(triple.object);
                edges.push(triple);
            }
            
            // Display unique nodes
            html += '<div style="margin: 10px 0;"><strong>Nodes:</strong><br>';
            for (const node of nodes) {
                if (isBNode(node)) {
                    html += `<span class="node bnode-node">${node}</span>`;
                } else if (node.startsWith('"')) {
                    html += `<span class="node literal-node">${node}</span>`;
                } else {
                    html += `<span class="node uri-node">${node}</span>`;
                }
            }
            html += '</div>';
            
            // Display edges
            html += '<div style="margin: 10px 0;"><strong>Relationships:</strong><br>';
            for (const edge of edges) {
                html += '<div style="margin: 5px 0; font-family: monospace; font-size: 0.9rem;">';
                html += formatTriple(edge);
                html += '</div>';
            }
            html += '</div>';
            
            container.innerHTML = html;
        }

        // Load example data
        function loadExample(type) {
            const examples = {
                simple: `_:b1 <http://example.org/name> "Alice" .
_:b1 <http://example.org/age> "30" .
<http://example.org/person1> <http://example.org/knows> _:b1 .`,
                
                complex: `_:b1 <http://example.org/name> "Alice" .
_:b1 <http://example.org/age> "30" .
<http://example.org/person1> <http://example.org/knows> _:b1 .
_:b2 <http://example.org/name> "Bob" .
_:b1 <http://example.org/friend> _:b2 .
_:b2 <http://example.org/friend> _:b1 .
<http://example.org/company> <http://example.org/employee> _:b1 .
<http://example.org/company> <http://example.org/employee> _:b2 .`
            };
            
            document.getElementById('rdf-input').value = examples[type];
        }

        // Initialize with simple example
        window.onload = function() {
            loadExample('simple');
            executeAlgorithm();
        };
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96a713f55336448a',t:'MTc1NDQwNTEyMy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
